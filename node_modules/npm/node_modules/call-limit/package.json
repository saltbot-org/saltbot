{
  "_from": "call-limit@~1.1.0",
  "_id": "call-limit@1.1.0",
  "_integrity": "sha1-b9YbA/PaQqLNDsK2DwK9DnGZH+o=",
  "_location": "/npm/call-limit",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "call-limit",
    "fetchSpec": "~1.1.0",
    "name": "call-limit",
    "raw": "call-limit@~1.1.0",
    "rawSpec": "~1.1.0",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "/npm"
  ],
  "_resolved": "https://registry.npmjs.org/call-limit/-/call-limit-1.1.0.tgz",
  "_shasum": "6fd61b03f3da42a2cd0ec2b60f02bd0e71991fea",
  "_shrinkwrap": null,
  "_spec": "call-limit@~1.1.0",
  "_where": "/Users/zkat/Documents/code/npm",
  "author": {
    "email": "me@re-becca.org",
    "name": "Rebecca Turner"
  },
  "bin": null,
  "bugs": {
    "url": "https://github.com/iarna/call-limit/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Limit the number of simultaneous calls to an async function",
  "devDependencies": {
    "tap": "^1.0.0"
  },
  "files": [
    "call-limit.js"
  ],
  "homepage": "https://npmjs.com/packages/call-limit",
  "license": "ISC",
  "main": "call-limit.js",
  "name": "call-limit",
  "optionalDependencies": {},
  "peerDependencies": {},
  "readme": "call-limit\n----------\n\nLimit the number of simultaneous executions of a async function.\n\n```javascript\nvar fs = require('fs')\nvar limit = require('call-limit')\nvar limitedStat = limit(fs.stat, 5)\n```\n\nOr with promise returning functions:\n\n```javascript\nvar fs = Bluebird.promisifyAll(require('fs'))\nvar limit = require('call-limit')\nvar limitedStat = limit.promise(fs.statAsync, 5)\n```\n\n### USAGE:\n\nGiven that:\n\n```javascript\nvar limit = require('call-limit')\n```\n\n### limit(func, maxRunning) → limitedFunc\n\nThe returned function will execute up to maxRunning calls of `func` at once. \nBeyond that they get queued and called when the previous call completes.\n\n`func` must accept a callback as the final argument and must call it when\nit completes, or `call-limit` won't know to dequeue the next thing to run.\n\nBy contrast, callers to `limitedFunc` do NOT have to pass in a callback, but\nif they do they'll be called when `func` calls its callback.\n\n### limit.promise(func, maxRunning) → limitedFunc\n\nThe returned function will execute up to maxRunning calls of `func` at once.\nBeyond that they get queued and called when the previous call completes.\n\n`func` must return a promise.\n\n`limitedFunc` will return a promise that resolves with the promise returned\nfrom the call to `func`.\n\n### limit.method(class, methodName, maxRunning)\n\nThis is sugar for:\n\n```javascript\nclass.prototype.methodName = limit(class.prototype.methodName, maxRunning)\n```\n\n### limit.method(object, methodName, maxRunning)\n\nThis is sugar for:\n\n```javascript\nobject.methodName = limit(object.methodName, maxRunning)\n```\n\nFor example `limit.promise.method(fs, 'stat', 5)` is the same as\n`fs.stat = limit.promise(fs.stat, 5)`.\n\n### limit.promise.method(class, methodName, maxRunning)\n\nThis is sugar for:\n\n```javascript\nclass.prototype.methodName = limit.promise(class.prototype.methodName, maxRunning)\n```\n\n### limit.promise.method(object, methodName, maxRunning)\n\nThis is sugar for:\n\n```javascript\nobject.methodName = limit.promise(object.methodName, maxRunning)\n```\n\nFor example `limit.promise.method(fs, 'statAsync', 5)` is the same as\n`fs.statAsync = limit.promise(fs.statAsync, 5)`.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/iarna/call-limit.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "version": "1.1.0"
}
