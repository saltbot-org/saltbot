{
  "_from": "socks@^1.1.10",
  "_id": "socks@1.1.10",
  "_inBundle": false,
  "_integrity": "sha1-W4t/x8jzQcU+0FbpKbe/Tei6e1o=",
  "_location": "/npm/pacote/make-fetch-happen/socks-proxy-agent/socks",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "socks",
    "fetchSpec": "^1.1.10",
    "name": "socks",
    "raw": "socks@^1.1.10",
    "rawSpec": "^1.1.10",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "/npm/pacote/make-fetch-happen/socks-proxy-agent"
  ],
  "_resolved": "https://registry.npmjs.org/socks/-/socks-1.1.10.tgz",
  "_shasum": "5b8b7fc7c8f341c53ed056e929b7bf4de8ba7b5a",
  "_shrinkwrap": null,
  "_spec": "socks@^1.1.10",
  "_where": "/Users/zkat/Documents/code/npm/node_modules/pacote/node_modules/make-fetch-happen/node_modules/socks-proxy-agent",
  "author": {
    "name": "Josh Glazebrook"
  },
  "bugs": {
    "url": "https://github.com/JoshGlazebrook/socks/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Samuel Gordalina"
    }
  ],
  "dependencies": {
    "ip": "^1.1.4",
    "smart-buffer": "^1.0.13"
  },
  "deprecated": false,
  "description": "A SOCKS proxy client supporting SOCKS 4, 4a, and 5. (also supports BIND/Associate)",
  "devDependencies": {},
  "engines": {
    "node": ">= 0.10.0",
    "npm": ">= 1.3.5"
  },
  "homepage": "https://github.com/JoshGlazebrook/socks",
  "keywords": [
    "agent",
    "associate",
    "bind",
    "client",
    "proxy",
    "socks",
    "socks 4",
    "socks 4a",
    "socks 5",
    "tor"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "socks",
  "optionalDependencies": {},
  "readme": "socks\n=============\n\nsocks is a full client implementation of the SOCKS 4, 4a, and 5 protocols in an easy to use node.js module.\n\n### Notice\nAs of February 26th, 2015, socks is the new home of the socks-client package.\n\n### Why socks?\n\nThere is not any other SOCKS proxy client library on npm that supports all three variants of the SOCKS protocol. Nor are there any that support the BIND and associate features that some versions of the SOCKS protocol supports.\n\nKey Features:\n* Supports SOCKS 4, 4a, and 5 protocols\n* Supports the connect method (simple tcp connections of SOCKS)  (Client -> SOCKS Server -> Target Server)\n* Supports the BIND method (4, 4a, 5)\n* Supports the associate (UDP forwarding) method (5)\n* Simple and easy to use (one function call to make any type of SOCKS connection)\n\n## Installing:\n\n`npm install socks`\n\n### Getting Started Example\n\nFor this example, say you wanted to grab the html of google's home page.\n\n```javascript\nvar Socks = require('socks');\n\nvar options = {\n    proxy: {\n        ipaddress: \"202.101.228.108\", // Random public proxy\n        port: 1080,\n        type: 5 // type is REQUIRED. Valid types: [4, 5]  (note 4 also works for 4a)\n    },\n    target: {\n        host: \"google.com\", // can be an ip address or domain (4a and 5 only)\n        port: 80\n    },\n    command: 'connect'  // This defaults to connect, so it's optional if you're not using BIND or Associate.\n};\n\nSocks.createConnection(options, function(err, socket, info) {\n    if (err)\n        console.log(err);\n    else {\n        // Connection has been established, we can start sending data now:\n        socket.write(\"GET / HTTP/1.1\\nHost: google.com\\n\\n\");\n        socket.on('data', function(data) {\n            console.log(data.length);\n            console.log(data);\n        });\n\n        // PLEASE NOTE: sockets need to be resumed before any data will come in or out as they are paused right before this callback is fired.\n        socket.resume();\n\n        // 569\n        // <Buffer 48 54 54 50 2f 31 2e 31 20 33 30 31 20 4d 6f 76 65 64 20 50 65...\n    }\n});\n```\n\n### BIND Example:\n\nWhen sending the BIND command to a SOCKS proxy server, this will cause the proxy server to open up a new tcp port. Once this port is open, you, another client, application, etc, can then connect to the SOCKS proxy on that tcp port and communications will be forwarded to each connection through the proxy itself.\n\n```javascript\nvar options = {\n    proxy: {\n        ipaddress: \"202.101.228.108\",\n        port: 1080,\n        type: 4,\n        command: \"bind\" // Since we are using bind, we must specify it here.\n    },\n    target: {\n        host: \"1.2.3.4\", // When using bind, it's best to give an estimation of the ip that will be connecting to the newly opened tcp port on the proxy server.\n        port: 1080\n    }\n};\n\nSocks.createConnection(options, function(err, socket, info) {\n    if (err)\n        console.log(err);\n    else {\n        // BIND request has completed.\n        // info object contains the remote ip and newly opened tcp port to connect to.\n        console.log(info);\n\n        // { port: 1494, host: '202.101.228.108' }\n\n        socket.on('data', function(data) {\n            console.log(data.length);\n            console.log(data);\n        });\n\n        // Remember to resume the socket stream.\n        socket.resume();\n    }\n});\n\n```\nAt this point, your original connection to the proxy server remains open, and no data will be received until a tcp connection is made to the given endpoint in the info object.\n\nFor an example, I am going to connect to the endpoint with telnet:\n\n```\nJoshs-MacBook-Pro:~ Josh$ telnet 202.101.228.108 1494\n Trying 202.101.228.108...\n Connected to 202.101.228.108.\n Escape character is '^]'.\n hello\n aaaaaaaaa\n```\n\nNote that this connection to the newly bound port does not need to go through the SOCKS handshake.\n\nBack at our original connection we see that we have received some new data:\n\n```\n8\n<Buffer 00 5a ca 61 43 a8 09 01>  // This first piece of information can be ignored.\n\n7\n<Buffer 68 65 6c 6c 6f 0d 0a> // Hello <\\r\\n (enter key)>\n\n11\n<Buffer 61 61 61 61 61 61 61 61 61 0d 0a> // aaaaaaaaa <\\r\\n (enter key)>\n```\n\nAs you can see the data entered in the telnet terminal is routed through the SOCKS proxy and back to the original connection that was made to the proxy.\n\n**Note** Please pay close attention to the first piece of data that was received.\n\n```\n<Buffer 00 5a ca 61 43 a8 09 01>\n\n        [005a] [PORT:2} [IP:4]\n```\n\nThis piece of data is technically part of the SOCKS BIND specifications, but because of my design decisions that were made in an effort to keep this library simple to use, you will need to make sure to ignore and/or deal with this initial packet that is received when a connection is made to the newly opened port.\n\n### Associate Example:\nThe associate command sets up a UDP relay for the remote SOCKS proxy server to relay UDP packets to the remote host of your choice.\n\n```javascript\nvar options = {\n    proxy: {\n        ipaddress: \"202.101.228.108\",\n        port: 1080,\n        type: 5,\n        command: \"associate\" // Since we are using associate, we must specify it here.\n    },\n    target: {\n        // When using associate, either set the ip and port to 0.0.0.0:0 or the expected source of incoming udp packets.\n        // Note: Some SOCKS servers MAY block associate requests with 0.0.0.0:0 endpoints.\n        // Note: ipv4, ipv6, and hostnames are supported here.\n        host: \"0.0.0.0\",\n        port: 0\n    }\n};\n\n\nSocks.createConnection(options, function(err, socket, info) {\n    if (err)\n        console.log(err);\n    else {\n        // Associate request has completed.\n        // info object contains the remote ip and udp port to send UDP packets to.\n        console.log(info);\n        // { port: 42803, host: '202.101.228.108' }\n\n        var udp = new dgram.Socket('udp4');\n\n        // In this example we are going to send \"Hello\" to 1.2.3.4:2323 through the SOCKS proxy.\n\n        var pack = Socks.createUDPFrame({ host: \"1.2.3.4\", port: 2323}, new Buffer(\"hello\"));\n\n        // Send Packet to Proxy UDP endpoint given in the info object.\n        udp.send(pack, 0, pack.length, info.port, info.host);\n    }\n});\n\n```\nNow assuming that the associate request went through correctly. Anything that is typed in the stdin will first be sent to the SOCKS proxy on the endpoint that was provided in the info object. Once the SOCKS proxy receives it, it will then forward on the actual UDP packet to the host you you wanted.\n\n\n1.2.3.4:2323 should now receive our relayed UDP packet from 202.101.228.108 (SOCKS proxy)\n```\n// <Buffer 68 65 6c 6c 6f>\n```\n\n## Using socks as an HTTP Agent\n\nYou can use socks as a http agent which will relay all your http\nconnections through the socks server.\n\nThe object that `Socks.Agent` accepts is the same as `Socks.createConnection`, you don't need to set a target since you have to define it in `http.request` or `http.get` methods.\n\nThe second argument is a boolean which indicates whether the remote endpoint requires TLS.\n\n```javascript\nvar socksAgent = new Socks.Agent({\n    proxy: {\n        ipaddress: \"202.101.228.108\",\n        port: 1080,\n        type: 5,\n    }},\n    true, // we are connecting to a HTTPS server, false for HTTP server\n    false // rejectUnauthorized option passed to tls.connect(). Only when secure is set to true\n);\n\nhttp.get({ hostname: 'google.com', port: '443', agent: socksAgent}, function (res) {\n    // Connection header by default is keep-alive, we have to manually end the socket\n    socksAgent.encryptedSocket.end();\n});\n```\n\n# Api Reference:\n\nThere are only three exported functions that you will ever need to use.\n\n### Socks.createConnection( options, callback(err, socket, info)  )\n> `Object` **Object containing options to use when creating this connection**\n\n> `function` **Callback that is called when connection completes or errors**\n\nOptions:\n\n```javascript\nvar options = {\n\n    // Information about proxy server\n    proxy: {\n        // IP Address of Proxy (Required)\n        ipaddress: \"1.2.3.4\",\n\n        // TCP Port of Proxy (Required)\n        port: 1080,\n\n        // Proxy Type [4, 5] (Required)\n        // Note: 4 works for both 4 and 4a.\n        type: 4,\n\n        // SOCKS Connection Type (Optional)\n        // - defaults to 'connect'\n\n        // 'connect'    - establishes a regular SOCKS connection to the target host.\n        // 'bind'       - establishes an open tcp port on the SOCKS for another client to connect to.\n        // 'associate'  - establishes a udp association relay on the SOCKS server.\n        command: \"connect\",\n\n\n        // SOCKS 4 Specific:\n\n        // UserId used when making a SOCKS 4/4a request. (Optional)\n        userid: \"someuserid\",\n\n        // SOCKS 5 Specific:\n\n        // Authentication used for SOCKS 5 (when it's required) (Optional)\n        authentication: {\n            username: \"Josh\",\n            password: \"somepassword\"\n        }\n    },\n\n    // Information about target host and/or expected client of a bind association. (Required)\n    target: {\n        // When using 'connect':    IP Address or hostname (4a and 5 only) of a target to connect to.\n        // When using 'bind':       IP Address of the expected client that will connect to the newly open tcp port.\n        // When using 'associate':  IP Address and Port of the expected client that will send UDP packets to this UDP association relay.\n\n        // Note:\n        // When using SOCKS 4, only an ipv4 address can be used.\n        // When using SOCKS 4a, an ipv4 address OR a hostname can be used.\n        // When using SOCKS 5, ipv4, ipv6, or a hostname can be used.\n        host: \"1.2.3.4\",\n\n        // TCP port of target to connect to.\n        port: 1080\n    },\n\n    // Amount of time to wait for a connection to be established. (Optional)\n    // - defaults to 10000ms (10 seconds)\n    timeout: 10000\n};\n```\nCallback:\n\n```javascript\n\n// err:  If an error occurs, err will be an Error object, otherwise null.\n// socket: Socket with established connection to your target host.\n// info: If using BIND or associate, this will be the remote endpoint to use.\n\nfunction(err, socket, info) {\n  // Hopefully no errors :-)\n}\n```\n\n### Socks.createUDPFrame( target, data, [frame] )\n> `Object` **Target host object containing destination for UDP packet**\n\n> `Buffer` **Data Buffer to send in the UDP packet**\n\n> `Number` **Frame number in UDP packet. (defaults to 0)**\n\nCreates a UDP packet frame for using with UDP association relays.\n\nreturns `Buffer` The completed UDP packet container to be sent to the proxy for forwarding.\n\ntarget:\n```javascript\n\n// Target host information for where the UDP packet should be sent.\nvar target =\n    {\n        // ipv4, ipv6, or hostname for where to have the proxy send the UDP packet.\n        host: \"1.2.3.4\",\n\n        // udpport for where to send the UDP packet.\n        port: 2323\n    }\n\n```\n\n### Socks.Agent( options, tls)  )\n> `Object` **Object containing options to use when creating this connection (see above in createConnection)**\n\n> `boolean` **Boolean indicating if we upgrade the connection to TLS on the socks server**\n\n\n# Further Reading:\nPlease read the SOCKS 5 specifications for more information on how to use BIND and Associate.\nhttp://www.ietf.org/rfc/rfc1928.txt\n\n# License\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/JoshGlazebrook/socks.git"
  },
  "version": "1.1.10"
}
